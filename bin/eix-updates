#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
# vim:set fileencoding=utf8:

def eix
  `LANG=C eix -n -I -c`
    .gsub(/: .*/,       '') # Remove package description
    .gsub(/^\[[^ ]\] /, '') # Remove update indicator "[u]"
    .gsub(/{[^ ]*}/i,   '') # Remove binary package indicator {tbz2}
    .gsub(/\(~\)/,      '') # Remove keyword indicator ~VERSION
    .gsub(/\^[a-z]/i,   '') # Remove package restriction indicator ^t
    .gsub(/\@[0-9\/]+/, '') # Remove install date @MM/DD/YYYY
    .gsub(/ \(/,       ' ') # Remove ' (' prefixing the versions
    .gsub(/\)$/,        '') # Remove ')' suffixing the verions
    .lines
    .reject { |l| /Found/i =~ l }
end

def parse_eix(lines = [])
  updates = {}

  lines.map { |l|
    package_name, *versions = l.strip.split(/ /)
    installed_versions, update_versions = versions.join(' ')
                                                  .split(/ -> /)
                                                  .map { |s| parse_eix_versions(s.split) }

    if installed_versions && !installed_versions.empty?
      installed_versions.each_pair { |installed_slot, installed_version|
        if update_versions &&
           update_versions[installed_slot] &&
           update_versions[installed_slot] != installed_version
          (updates[package_name] ||= {})[installed_slot] = [ installed_version,
                                                             update_versions[installed_slot] ]
        end
      }
    end
  }

  updates
end

def parse_eix_versions(lines = [])
  versions = {}

  lines.each { |l|
    v = parse_eix_version(l)
    versions[v[:slot]] = v[:version]
  }

  versions
end

def parse_eix_version(line = "")
  version, slot = line.sub(/\)$/, '').split(/[(\/]/)
  { version: version,
    slot:    (slot || 0).to_s, }
end

def eix_updates
  parse_eix(eix())
end

if __FILE__ == $0
  updates         = eix_updates()
  name_width      = updates.keys.map(&:length).max
  installed_width = updates.values.map { |v| v.values.first }.flatten.map(&:length).max
  updates_width   = updates.values.map { |v| v.values.last  }.flatten.map(&:length).max
  update_format   = "%<name>-#{name_width}s " +
                    "(%<slot>s) " +
                    "%<installed>-#{installed_width}s -> " +
                    "%<update>-#{updates_width}s"

  updates.each_pair { |package_name, updates|
    updates.each_pair { |slot, versions|
      puts update_format % { name:      package_name,
                             slot:      slot,
                             installed: versions.first,
                             update:    versions.last, }
    }
  }
end
