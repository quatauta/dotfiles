# vim:syntax=zsh:

# Copied and adapted from Nicolas Gallagher (necolas)
# https://github.com/necolas/dotfiles/blob/master/shell/bash_prompt
prompt_git_status() {
    local prefix="$1"
    local suffix="$2"
    local prefix_dirty="$3"
    local suffix_dirty="$4"

    local branch=""
    local branch_status=""

    local remote_drift="#"
    local uncommitted="+"
    local unstaged="!"
    local untracked="?"
    local stashed="$"

    # check if the current directory is in a git repository
    if git rev-parse --is-inside-work-tree 1>/dev/null 2>&1 ; then
        # check if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" = "false" ]; then
            git update-index --really-refresh  -q 1>/dev/null 2>&1 # ensure index is up to date

            [ -n "$(git rev-list HEAD...@{upstream} 2>/dev/null)" ]            && branch_status+="${remote_drift}"
            $(git diff --quiet --ignore-submodules --cached  1>/dev/null 2>&1) || branch_status+="${uncommitted}"
            $(git diff-files --quiet --ignore-submodules --  1>/dev/null 2>&1) || branch_status+="${unstaged}"
            [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]   && branch_status+="${untracked}"
            $(git rev-parse --verify refs/stash              1>/dev/null 2>&1) && branch_status+="${stashed}"

            [ "" != "${branch_status}" ] && branch_status="${prefix_dirty}${branch_status}${suffix_dirty}"
        fi

        # get the short symbolic ref
        # if HEAD isn't a symbolic ref, get the short SHA
        # otherwise, just give up
        branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null || \
                  git rev-parse --short HEAD 2>/dev/null || \
                  printf "(unknown)")"

        printf "%s" "${prefix}${branch}${suffix}${branch_status}"
    else
        return
    fi
}
